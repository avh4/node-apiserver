{"google":"UA-31468476-1","tagline":"A ready to go, modular, multi transport, streaming friendly, JSON(P) API Server for Node.js","body":"# apiserver [![build status](https://secure.travis-ci.org/kilianc/node-apiserver.png?branch=master)](http://travis-ci.org/kilianc/node-apiserver)\r\n\r\nA ready to go, modular, multi transport, streaming friendly, JSON(P) API Server.\r\n\r\n## Why use ApiServer and not [restify](https://github.com/mcavage/node-restify) or [express](https://github.com/visionmedia/express)?\r\n\r\nStrong competitors I guess.\r\n\r\n__Express__ targets web applications providing support for templates, views, and all the facilities the you probably need if you're writing a web app. __Restify__ let you \"build \"strict\" API services\" but it's too big and it concentrates on server to server API, that will not be consumed by your browser.\r\n\r\n__ApiServer__ is rad. It is a slim, fast, minimal API framework, built to provide you a flexible API consumable both in the browser and from other apps. It ships with JSON, JSONP [__(GET/POST)__](https://github.com/kilianc/node-json-transport) transports and a powerful [fast routing engine](https://github.com/kilianc/node-apiserver-router) OOTB. The source code is small, heavily tested and decoupled. Your API source will be well organized in context objects, allowing you to keep it in a meaningful maintainable way.\r\n\r\n### Killer features\r\n\r\n* Streaming JSON(P) transport GET/POST browser friendly\r\n* Fast routing system with cached routes\r\n* API modules as Objects/Classes\r\n* Payload paused by default\r\n* Transports decoupled from the core\r\n* Router decoupled from the core\r\n* Compatible with [express](https://github.com/visionmedia/express) middleware\r\n\r\n## Installation\r\n\r\n    âš¡ npm install apiserver\r\n\r\n```javascript\r\nvar ApiServer = require('apiserver')\r\n```\r\n# Class Methods\r\n\r\n## Class Method: constructor\r\n\r\n### Syntax:\r\n\r\n```javascript\r\nnew ApiServer([options])\r\n```\r\n\r\n### Available Options:\r\n\r\n* __port__ - (`Number|String`: defaults to 8080) the server binding port\r\n* __server__ - (`http(s).Server`: defaults http.Server)\r\n* __timeout__ - (`Number`: defaults to 15000) milliseconds to wait before arbitrary closing the connection\r\n* __router__ - (`Object`: defaults to the standard [router](#router)) the routes manager conforms to the [router interface](#router-interface)\r\n* __standardHeaders__ - (`Object`: below the default) response headers defaults, can be overwritten by the [transport](#transports)\r\n\r\n```javascript\r\n{\r\n  'cache-control': 'max-age=0, no-cache, no-store, must-revalidate',\r\n  'expires': 0,\r\n  'pragma': 'no-cache',\r\n  'x-server': 'ApiServer v' + ApiServer.version + ' raging on nodejs ' + process.version\r\n}\r\n```\r\n\r\n### Example:\r\n\r\n```javascript\r\nvar https = require('https'),\r\n    ApiServer = require('apiserver')\r\n\r\napiserver = new ApiServer({\r\n  port: 80,\r\n  server: https.createServer(),\r\n  standardHeaders: {\r\n    'cache-control': 'max-age=0, no-cache, no-store, must-revalidate',\r\n    'x-awesome-field': 'awezing value'\r\n  },\r\n  timeout: 2000\r\n})\r\n```\r\n\r\n## Class Method: addModule\r\n\r\nAdds a new [module](#modules) to to the current API set. It triggers the `router.update` method.\r\n\r\n### Syntax:\r\n\r\n```javascript\r\nApiServer.prototype.addModule(version, moduleName, apiModule)\r\n```\r\n\r\n### Arguments:\r\n\r\n* __version__ - (`String`) the version of the API you want to add your module to, it will be the first part of the url\r\n* __moduleName__ - (`String`) the name of the module, this will be the second part of your derived routes, after a [case conversion](#modules)\r\n* __apiModule__ - (`Object`) the module object conform to the [modules interface](#module-interface)\r\n\r\n### Examples:\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.addModule('v1', 'user', userModule)\r\napiserver.addModule('v1', 'pages', pageModule)\r\napiserver.addModule('v2', 'user', userModule2)\r\n```\r\n\r\n## Class Method: use\r\n\r\nAdds a middleware object to the [middleware chain](#middleware-chain). It triggers the `router.update` method.\r\n\r\nEach middleware is associated to a `RegExp` used to test the API end-point route. If the route matches the `RegExp` the middleware will be a part of the chain and will be executed.\r\n\r\nRead more about middleware [here](#middleware).\r\n\r\n### Syntax:\r\n\r\n```javascript\r\nApiServer.prototype.use(route, middleware)\r\n```\r\n\r\n### Arguments:\r\n\r\n* __route__ - (`RegExp`) regular expression that the route should match\r\n* __middleware__ - (`Object`) the middleware object conforms to the [middleware interface](#middleware-interface)\r\n\r\n### Examples:\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.use(/./, new MyMiddleWare({ foo: 'bar', bar: true }))\r\napiserver.use(/(signin|signup)/, ApiServer.payloadParser())\r\napiserver.use(/^\\/v1\\/files\\/upload$/, ApiServer.multipartParser())\r\n```\r\n\r\n## Class Method: listen\r\nBind the server to a port\r\n\r\n### Syntax:\r\n\r\n```javascript\r\nApiServer.prototype.listen([port], [callback])\r\n```\r\n\r\n### Arguments:\r\n\r\n* __port__ - (`Number|String`) overwrite the constructor __port__ parameter\r\n* __callback__ - (`Function`) called when the port is actually bound to the server\r\n\r\n### Example:\r\n_From this point on, all the examples will take the require statements as assumption_\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.listen(80, function (err) {\r\n  if (err) {\r\n    console.error('Something terrible happened: %s', err.message)\r\n  } else {\r\n    console.log('Successful bound to port %s', this.port)\r\n  }\r\n})\r\n```\r\n\r\n## Class Method: close\r\nUnbind the server from the current port\r\n\r\n### Syntax:\r\n\r\n```javascript\r\nApiServer.prototype.close([callback])\r\n```\r\n\r\n### Arguments:\r\n\r\n* __callback__ - (`Function`) called when the port is actually unbound from the server\r\n\r\n### Example:\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.listen(80, onListen)\r\n\r\nfunction onListen(err) {\r\n  if (err) {\r\n    console.error('Something terrible happened: %s', err.message)\r\n  } else {\r\n    setTimeout(function () {\r\n      apiserver.close(onClose)\r\n    }, 5000)\r\n  }\r\n}\r\n\r\nfunction onClose() {\r\n  console.log('port unbound correctly')\r\n}\r\n```\r\n\r\n# Class Events\r\n\r\n## Class Event: requestEnd\r\n\r\nEmitted when an API method closes the response, even with `response.end`.\r\n\r\n### Event data\r\n\r\n```javascript\r\napiserver.on('requestEnd', function (url, responseTime) {\r\n  \r\n})\r\n```\r\n\r\n  * __url__ (`String`) - the `request.url`\r\n  * __responseTime__ (`Number`) - how log the API method took for closing the response\r\n\r\n## Class Event: timeout\r\n\r\nEmitted when an API method exceed the maximum allowed time ([see `timenout` option](#class-method-constructor)), before closing the response.\r\n\r\n### Event data\r\n\r\n```javascript\r\napiserver.on('timenout', function (url) {\r\n\r\n})\r\n```\r\n\r\n  * __url__ (`String`) - the `request.url`\r\n\r\n## Class Event: error\r\n\r\nEmitted when a __sync__ error is triggered during the [middleware chain](#middleware-chain) execution, can be both your API, a transport or a simple middleware.\r\n\r\n_You still have to deal with async errors_\r\n\r\n### Event data\r\n\r\n```javascript\r\napiserver.on('error', function (url, err) {\r\n  \r\n})\r\n```\r\n\r\n  * __url__ (`String`) - the `request.url`\r\n  * __err__ (`Error`) - the error which triggered the event\r\n\r\n# Modules\r\n\r\nA module is a set of API __end-points__ grouped in the same __context__:\r\n\r\n* __context__: a simple object\r\n* __end-point__: function/method accessible by the object and scoped within the object\r\n\r\n## Modules Interface\r\n\r\nEach module method (API end-point) must implement this interface and expect request and response parameters\r\n\r\n```javascript\r\nfunction (request, response)\r\n```\r\n\r\nThe request object is [\"extendend\" ootb](https://github.com/kilianc/node-apiserver/blob/master/lib/apiserver.js#L102]) with the following members:\r\n\r\n* __requestedAt__: timestamp of the request\r\n* __parsedUrl__: a parsed version of the request url\r\n* __pathname__: the pathname that corresponds to the end-point route\r\n* __querystring__: the querystring object parsed with [visionmedia/node-querystring](https://github.com/visionmedia/node-querystring)\r\n\r\nAs you can see, there is no callback to call, you have to deal directly with the response.\r\n\r\nTake a look at your [transport documentation](#transports) and use the right method that ships within the response object. You can also roughly close and write to the response __stream__ in an edge case.\r\n\r\n## Modules Examples\r\n\r\n### Object literal\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\n```\r\n\r\n```javascript\r\nvar userModule = {\r\n  signin: function (request, response) {\r\n    // rough approach\r\n    response.writeHead(200)\r\n    response.end('ok')\r\n  },\r\n  signout: function (request, response) {\r\n    // JSON transport\r\n    response.serveJSON({ foo: 'bar' })\r\n  }\r\n}\r\n```\r\n\r\n```javascript\r\napiserver.addModule('v1', 'user', userModule)\r\n```\r\n\r\n### Class\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\n```\r\n\r\n```javascript\r\nvar UserModule = function (options) {\r\n  this.database = options.database\r\n  this.serviceName = options.serviceName\r\n}\r\n\r\nUserModule.prototype.signin = function (request, response) {\r\n  var self = this\r\n  self.database.searchUser(request.querystring.username, function (err) {\r\n    if (err) {\r\n      response.serveJSON({ success: true, err: err.message })\r\n    } else {\r\n      response.serveJSON({ success: true, message: 'welcome to ' + self.serviceName })\r\n    }\r\n  })\r\n}\r\n\r\nUserModule.prototype.signout = function (request, response) {\r\n  // you can use the response as usual\r\n  // a redirect for example\r\n  response.writeHead(302, {\r\n    'location': 'http://example.org/logout_suceesful'\r\n  })\r\n  response.end()\r\n}\r\n```\r\n\r\n```javascript\r\nvar database = /* your db object*/\r\napiserver.addModule('v1', 'user', new UserModule(database, 'My Awesome Service'))\r\n```\r\n\r\n# Middleware\r\n\r\nThe concept of middleware is not new at all, you can find the same pattern in [visionmedia/express](https://github.com/visionmedia/express) in  [mcavage/node-restify](https://github.com/mcavage/node-restify) and in many others. A [middleware](http://en.wikipedia.org/wiki/Middleware) is a piece of software that adds (or patches) a feature into another software. Usually there is a common interface to implement, because the caller software, in this case our __ApiServer__, should know how to interact with the middleware.\r\n\r\n_You should check out the [source code](https://github.com/kilianc/node-apiserver/tree/master/lib/middleware) for a large understanding, middleware is relatively easy to code._\r\n\r\n## Middleware Chain\r\n\r\nThe __ApiServer__ uses [kilianc/node-fnchain](https://github.com/kilianc/node-fnchain) to [execute all the active middleware](https://github.com/kilianc/node-apiserver/blob/master/lib/apiserver.js#L131) and reach the API method (that actually is the last ring of the chain). This means that the order of the execution depends on the order you activated the middleware.\r\n\r\nEach middleware can both exit with an error or explicitly stop the chain (not reaching your API method). This is useful in case of a precondition check (auth, sessions, DoS attack filter...), or just because you packed some shared code as middleware which must be executed before your API method.\r\n\r\nAt the middleware execution level, the response object is already patched with the default transport methods, so you can use these methods to write and close the response. Is a good practice to leave at the top of the chain the extra transports middleware.\r\n\r\n```javascript\r\n// constructor adds the default transport automatically\r\nvar apiserver = new ApiServer()\r\n\r\n// lets ad first our custom transports\r\napiserver.use(/\\.xml$/, myXMLTransport())\r\napiserver.use(/\\.csv$/, myCSVTransport())\r\napiserver.use(/\\.yml$/, myYAMLTransport())\r\n\r\n// now activate our middleware\r\napiserver.use(/form/, ApiServer.payloadParser())\r\napiserver.use(/upload/, ApiServer.multipartParser())\r\n\r\n...\r\n```\r\n\r\n__The request payload (the `data` event) is paused by default and can be resumed calling `request.resume()` at any level of execution: middleware, module, transport.__ Why? Because you should explicitly accept or refuse a payload, this way you will save memory not buffering useless data.\r\n\r\nTake a look at both the [pause](http://nodejs.org/api/all.html#all_request_pause) and [resume](http://nodejs.org/api/all.html#all_request_resume) official docs.\r\n\r\n_ApiServer is using [this patch](https://github.com/kilianc/node-buffered-request) to provide a robust buffered pause resume method, so you don't have do deal with the flying chunks after the pause call_\r\n\r\n## Middleware Interface\r\n\r\nEach middleware must implement this interface.\r\n\r\n```javascript\r\nmodule.exports = function (options) {\r\n  return function (request, response, next) {\r\n    // do sometihng async and when you're done call the callback\r\n    options.count++\r\n    next()\r\n  }\r\n}\r\n```\r\n\r\nA middleware basically, is a function that returns another function, this one must declare 3 paramaters:\r\n\r\n* __request__: the server request already extended by the server\r\n* __response__: the server response already extended by the transports\r\n* __next__: a callback in the following form `function (err, stop)`\r\n\r\nThe `next` callback expects 2 parameters:\r\n\r\n* __err__ - (`Error`) an error object that will throw a server error event and will close the response\r\n* __stop__ - (`Boolean`) a flag that stops the internal chain, that means that your API method will never be called and your middleware should be able to correctly close the response. At this point you already have all the transports available, and you can freely use them.\r\n\r\n## Transports\r\n\r\nA transport is a particular middleware that \"extends\" the response object. It can provide new methods that allow you to serve your data to the client in different ways. \r\n\r\nUsually this is how you send data back to the client:\r\n\r\n```javascript\r\nfunction (request, response) {\r\n  response.writeHead(200, {\r\n    'content-type': 'application/json'\r\n  })\r\n  response.end(JSON.stringify({ foo: 'bar' }))\r\n})\r\n```\r\n\r\nThis is for example how the default [JSONTransport](https://github.com/kilianc/node-json-transport) simplify the process\r\n\r\n```javascript\r\nfunction (request, response) {\r\n  response.serveJSON({ foo: 'bar' })\r\n})\r\n```\r\n\r\nBasically what a transport does, is to wrap your data around a meaningful format (JSON, JSONP, HTML, XML, CSV, ...) understandable by your clients. It takes care of all the small things that the raw response needs (headers, status codes, buffering, ...)\r\n\r\nTransports must be at the top of the middleware chain, in order to allow other middleware to use them.\r\n\r\n[JSONTransport](https://github.com/kilianc/node-json-transport) is the default one, is attached before the middleware chain execution and then is available at every level of execution. You don't need to allocate it directly, the server itself will allocate the transport passing as options the __ApiServer__ [constructor](#class-method-constructor) options object.\r\n\r\n### Example\r\n\r\n```javascript\r\nmodule.exports = function (options) {\r\n  function serve<FORMAT>(request, response, data, options) {\r\n    response.writeHead(200, {\r\n      'content-type': 'application/<FORMAT>'\r\n    })\r\n    response.end(<FORMAT>.stringify(data))\r\n  }\r\n  return function (request, response) {\r\n    // attach some new method to the response\r\n    response.serve<FORMAT> = serve<FORMAT>.bind(this, request, response)\r\n  }\r\n}\r\n```\r\n\r\nwhere `<FORMAT>` is the formatting method of your data.\r\n\r\n# Router\r\n\r\nApiserver uses [apiserver-router](https://github.com/kilianc/node-apiserver-router) as default router, a fast routing system with integrated caching. It basically translates your API methods names in routes, doing some convenient case conversion.\r\n\r\nYou can change the default behavior passing a custom router as `router` option in the Apiserver [constructor](#class-method-constructor).\r\n\r\n## Example\r\n\r\n```javascript\r\nvar UserModule = function (options) {\r\n  this.options = options\r\n}\r\n\r\n// will be translated into /1/random_photo_module/create_album\r\nUserModule.prototype.createAlbum = function (request, response) { ... }\r\n\r\n// will be translated into /1/random_photo_module/upload_photo\r\nUserModule.prototype.uploadPhoto = function (request, response) { ... }\r\n\r\n// private method, skipped by the router\r\nUserModule.prototype._checkFileExtension = function (request, response) { ... }\r\n\r\n```\r\n\r\n```javascript\r\napiserver.addModule('1', 'randomPhotoModule', new UserModule())\r\n```\r\n\r\nN.B. the `moduleName` also will be translated\r\n\r\n## Router Interface\r\n\r\n```javascript\r\nnew Router()\r\nRouter.prototype.update(modules, middlewareList)\r\nRouter.prototype.get(pathname)\r\n```\r\n# Bundled Middleware\r\n\r\n## JSONTransport\r\n\r\n[JSONTransport](https://github.com/kilianc/node-json-transport) is the default transport bundled with ApiServer and we can call it the real __killer feature__.\r\n\r\nIt provides JSON and JSONP that work with both GET / POST methods.\r\n\r\n### Examples\r\n\r\n```javascript\r\n// decontextualized API method\r\nfunction (request, response) {\r\n  response.serveJSON({ foo: 'bar' })\r\n})\r\n```\r\n\r\n```javascript\r\n// decontextualized API method\r\nfunction (request, response) {\r\n  response.serveJSON(['foo','bar', ...], {\r\n    httpStatusCode: 404,\r\n    httpStatusMessage: 'maybe.. you\\'re lost',\r\n    headers: {\r\n      'x-value': 'foo'\r\n    }\r\n  })\r\n})\r\n```\r\n```javascript\r\n// decontextualized API method\r\nfunction (request, response) {\r\n  var count = 3\r\n  var interval = setInterval(function () {\r\n    if (count === 0) {\r\n      clearInterval(interval)\r\n      response.streamJSON()\r\n    } else {\r\n      count--\r\n      response.streamJSON({ foo: 'bar' })\r\n    }\r\n  }, 200)\r\n})\r\n```\r\n\r\nyields\r\n\r\n```javascript\r\n[\r\n   { \"foo\": \"bar\" },\r\n   { \"foo\": \"bar\" },\r\n   { \"foo\": \"bar\" }\r\n]\r\n```\r\n\r\nRead the full docs [here](https://github.com/kilianc/node-json-transport)\r\n\r\n## payloadParser\r\n\r\nThe payload parser automatically `resume()` the payload, __buffer it__ and parse it. It only works with __PUT POST OPTIONS__ http methods, because they are the only that can carryout a payload by specs definition.\r\n\r\nTwo kinds of payload can be parsed:\r\n\r\n* `application/x-www-form-urlencoded`\r\n* `application/json`\r\n\r\nThe following attributes will be attached to the request object:\r\n\r\n* __body__: an object containing the parsed data\r\n* __rawBody__: the raw payload as binary [buffer](http://nodejs.org/api/all.html#all_buffer)\r\n* __parseError__: can be `null` or `Error` in case of parse error\r\n\r\n### Syntax\r\n\r\n```javascript\r\nApiServer.payloadParser()\r\n```\r\n\r\n### Example\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.use(/1\\/my_module\\/my_method_api$/, ApiServer.payloadParser())\r\napiserver.addModule('1', 'myModule', {\r\n  'my_method_api': function (request, response) {\r\n    if (request.parseError) {\r\n      // :(\r\n      console.error(request.parseError.message)\r\n    } else {\r\n      request.body // an object containing the parsed data\r\n      request.rawBody // contains a binary buffer with your payload\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n## multipartParser\r\n\r\nThe multipart-parser automatically `resume()` the payload, and attach it to a [felixge/node-formidable](https://github.com/felixge/node-formidable) `IncomingForm` object. It only works with __PUT POST OPTIONS__ http methods, because they are the only that can carryout a payload by specs definition.\r\n\r\nOnly a `multipart/form-data` payload is parsed and the following attribute will be attached to the request object:\r\n\r\n* __form__ an IncomingForm object, [read how to deal with it](https://github.com/felixge/node-formidable)\r\n\r\n### Syntax\r\n\r\n```javascript\r\nApiServer.multipartParser()\r\n```\r\n\r\n### Example\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.use(/1\\/my_module\\/my_method_api$/, ApiServer.multipartParser())\r\napiserver.addModule('1', 'myModule', {\r\n  'my_method_api': function (request, response) {\r\n    var fields = Object.create(null)\r\n    request.form.on('field', function (name, value) {\r\n      fields[name] = value\r\n    })\r\n    request.form.on('file', function (name, file) {\r\n      fields[name] = fs.readFileSync(file.path, 'utf8')\r\n    })\r\n    request.form.once('end', function () {\r\n      // do something with your data\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n## httpAuth\r\n\r\nThe httpauth middleware acts as an auth precondition, checking the `authorization` headers sent with the request.\r\n\r\nIf the request doesn't pass the authorization check, httpauth [will close the response](https://github.com/kilianc/node-apiserver/blob/refactor/lib/middleware/httpauth.js#L34) using the standard JSONTransport:\r\n\r\n```javascript\r\nresponse.serveJSON(null, {\r\n  httpStatusCode: 401,\r\n  headers: { 'www-authenticate': 'Basic realm=\\'' + realm + '\\'' }\r\n})\r\n```\r\n\r\nThis will trigger a user/password prompt in your browser\r\n\r\n### Syntax\r\n\r\n```javascript\r\nApiServer.httpauth([options])\r\n```\r\n\r\n### Options\r\n* __realm__: (`String`) the name of your service, this is used by the browser when it prompts for username and password\r\n* __credentials__ - (`Array`) a list of strings (credentials), if your client is a browser you must use the form _username:password_\r\n* __encode__: (`Boolean`: defaults to false) set to true if your client is a browser (will base64 encode)\r\n\r\n### Example\r\n\r\n```javascript\r\nvar apiserver = new ApiServer()\r\napiserver.use(/1\\/admin\\/.+/, ApiServer.httpauth({\r\n  realm: 'signin please',\r\n  credentials: ['foo:password','bar:password', ...],\r\n  encode: true // we suppose that at the other end of the wire we have a browser\r\n}))\r\napiserver.addModule('1', 'admin', {\r\n  'protectedApi': function (request, response) {\r\n    // this will executed only if you provide valid credentials\r\n  }\r\n})\r\n```\r\n\r\n# How to contribute\r\n\r\n__ApiServer__ follows the awesome [Vincent Driessen](http://nvie.com/about/) [branching model](http://nvie.com/posts/a-successful-git-branching-model/).\r\n\r\n* You must add a new feature on his own topic branch\r\n* You must contribute to hot-fixing directly into the master branch (and pull-request to it)\r\n\r\nApiServer follows (more or less) the [Felix's Node.js Style Guide](http://nodeguide.com/style.html), your contribution must be consistent with this style.\r\n\r\nThe test suite is written on top of [visionmedia/mocha](http://visionmedia.github.com/mocha/) and it took hours of hard work. Please use the tests to check if your contribution is breaking some part of the library and add new tests for each new feature.\r\n\r\n    âš¡ npm test\r\n\r\nand for your test coverage\r\n\r\n    âš¡ make test-cov\r\n\r\n## License\r\n\r\n_This software is released under the MIT license cited below_.\r\n\r\n    Copyright (c) 2010 Kilian Ciuffolo, me@nailik.org. All Rights Reserved.\r\n\r\n    Permission is hereby granted, free of charge, to any person\r\n    obtaining a copy of this software and associated documentation\r\n    files (the 'Software'), to deal in the Software without\r\n    restriction, including without limitation the rights to use,\r\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the\r\n    Software is furnished to do so, subject to the following\r\n    conditions:\r\n    \r\n    The above copyright notice and this permission notice shall be\r\n    included in all copies or substantial portions of the Software.\r\n    \r\n    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n    OTHER DEALINGS IN THE SOFTWARE.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Node.js ApiServer"}